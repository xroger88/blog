#+TITLE: Clojure and Libraries
#+AUTHOR: xroger88
#+TAGS: clojure language
#+DESCRIPTION: 클로저 언어 및 관련 라이브러리 학습 노트

Clojoure Development.
...

* Introduction
- What is Clojure? Clojure is a programming language created by Rich Hickey, that was released in 2007.
- It is: A dialect of Lisp =Powerful with many, many brackets Hosted on the Java Virtual Machine (JVM) Parasitises Java’s stability/performance and can use Java libraries Dynamically compiled =Faster than scripting languages. Turned into Java byte code for the JVM An impure functional programming language= Does not enforce the functional paradigm Aimed at Concurrency / Asynchronous Programming Currently at version 1.7, see more [[https://medium.com/@FunctionalWorks/from-0-to-clojure-in-540-seconds-7ce6842f57f9][article1]] [[https://medium.com/@val.vvalval/what-datomic-brings-to-businesses-e2238a568e1c][article2]]
* Basic References
- *Programming Clojure* authored by Stuart Halloway : 기본 입문서
- [[https://www.braveclojure.com/introduction/][CLOJURE for the BRAVE and TRUE]] : 클로저 개발에 필요한 것들을 쉽게 자세히 설명해 주는 책! (필독 강추)

* Build & Debugging Tools
- Leiningen
- Cider in emacs
- lein-figwheel & figwheel-main for clojurescript
- shadow-cljs for clojurescript
- rebel-readline
- tools.deps - deps.edn

* Language Extension Libraries
- Monad (algo.monad)

* Asynchronous Abstraction Libraries
- Manifold by Zach Tellman
  - high level abstractions for asynchronous things in Clojure : [[https://medium.com/@functionalhuman/a-tour-of-manifold-an-easy-to-use-library-of-building-blocks-for-asynchronous-programming-f4bb5d9c6ba9][a tour of manifold an easy to use library of building blocks for asynchronous programming]]
  - Manifold.deferred - Methods for creating, transforming, and interacting with asynchronous values.
  - Manifold.streams - Manifold’s streams provide mechanisms for asynchronous puts and takes, timeouts, and backpressure. They are compatible with Java’s BlockingQueues, Clojure's lazy sequences, and core.async's channels. Methods for converting to and from each are provided.
  - Manifold.bus - Manifold also provides a simple event bus that can be used for pub/sub communication.
- Promesa
- Porsas (metosin) - tools for precompiling the functions to convert database results into Clojure values. This enables basically Java-fast database queries using idiomatic Clojure.

* Application Framework & Libraries
- Ring (HTTP support in clojure)
  - wrap-params (parsing params)
  - wrap-reload (for development)
  - wrap-resource and wrap-file-info (static files)
- Route match and dispatch, Restful Application Libraries
  - Compojure
  - Bidi (JUXT)
  - Compojure-api
  - Liberator - [[https://github.com/clojure-liberator/liberator][clojure-liberator]]
  - Reitit
- Re-frame (event/effect/subscription, application-state management)
- Reagent (react-like component render, data -> hiccup conversion)
- Hiccup - HTML representation in clojure
- Duck Framework for Server Application Dev - [[https://github.com/duct-framework/duct][github]]
  Duct is a highly modular framework for building server-side applications in Clojure using data-driven architecture. It is similar in scope to Arachne, and is based on Integrant. Duct builds applications around an immutable configuration that acts as a structural blueprint. The configuration can be manipulated and queried to produce sophisticated behavior.
  - [[https://github.com/duct-framework/docs/blob/master/GUIDE.rst][Guide doc]]
  - see a lot of modules in [[https://github.com/duct-framework/duct/wiki/Modules][github]]
    Clojure/Datomic migrations library branched from rkneufeld/conformity [[https://github.com/magnetcoop/stork][see this]]

* Database as a value
- Datomic - immutable, single writer model (reified transaction): [[https://www.datomic.com][datomic home]]
- Crux - document oriendted bitemporality (tx-time, valid-time), unbundled database : [[https://opencrux.com][crux home]]
  - Crux Console Implementation - modify it as you want

* SQL for Clojure(Script)
- clojure.java.jdbc, jdbc.next - see [[https://github.com/seancorfield/next-jdbc][github]]
- how to connect mssql

#+BEGIN_SRC clojure
{% highlight clojure %}
(require '[next.jdbc :as jdbc])
(def db {:dbtype "mssql"
         :dbname "database-name"
         :host "host" ;;optional
         :port "port" ;;optional
         :user "sql-authentication-user-name"
         :password "password"})
(def con (jdbc/get-connection db))
(jdbc/execute! con ["select * from sys.objects  where type = 'U'"])

; leiningen configuration
:dependencies [[seancorfield/next.jdbc "1.0.13"]
               [com.microsoft.sqlserver/mssql-jdbc "7.4.1.jre11"]]
{% endhighlight %}
#+END_SRC
- db spec -> db source -> db connection
- Primitive SQL APIs: plan, execute!, execute-one!
- Friendly SQL Functions: insert!, insert-multi!, query, update!, delete!
  If you need more expressiveness, consider one of the following libraries to build SQL/parameter vectors, or run queries:

- HoneySQL -- a composable DSL for creating SQL/parameter vectors from Clojure data structures
- seql -- a simplified EQL-inspired query language, built on next.jdbc (as of release 0.1.6)
- SQLingvo -- a composable DSL for creating SQL/parameter vectors
- Walkable -- full EQL query language support for creating SQL/parameter vectors
- HugSQL -- If you prefer to write your SQL separately from your code, take a look at HugSQL

- RagTime - [[https://github.com/weavejester/ragtime][see this]]
  - Ragtime is a Clojure library for migrating structured data in a way that's database independent. It defines a common interface for expressing migrations, much like Ring defines a common interface for expressing web applications. Ragtime needs three pieces of data to work: migratable data store, an ordered sequence of migrations,strategy on how to deal with conflicts
- HugSQL
- HoneySQL
- Walkable

* Reloaded Workflow [Application State Management]
- Introduction
  - The reloaded workflow uses components that can be started or stopped, arranged together into a system. During development, the system is started in a running REPL. After source files are changed, the system is stopped, the source files reloaded, and the system started once more. This can be put into a single command or even attached to a shortcut. A component could include stuff like reading configuration database connection running a Jetty server A short list of libraries offering support for this approach: Component [[https://github.com/stuartsierra/component][see this]] [Excerpted from Stuartssierra's component github site]
#+BEGIN_QUOTE
A component is a collection of functions or procedures which share some runtime
state. Some examples of components:
- Database access: query and insert fucntions sharing a database connection
- External API service: functions to send receive data sharing an HTTP
  connection pool
- Web server: functions to handle different routes sharing all the runtime state
  of the web application, such as a session store
- In-memory cache: functions to get and set data in a shared mutable reference
  such as a Clojure Atom or Ref
Commponents are intended to help manage stateful resources within a function paradigm.
#+END_QUOTE
- Integrant [[https://github.com/weavejester/integrant][see this]]
  - Integrant is a Clojure (and ClojureScript) micro-framework for building applications with data-driven architecture. It can be thought of as an alternative to Component or Mount, and was inspired by Arachne and through work on Duct. Rationale: Integrant was built as a reaction to fix some perceived weaknesses with Component. In Component, systems are created programmatically. Constructor functions are used to build records, which are then assembled into systems. In Integrant, systems are created from a configuration data structure, typically loaded from an edn resource. The architecture of the application is defined through data, rather than code. In Component, only records or maps may have dependencies. Anything else you might want to have dependencies, like a function, needs to be wrapped in a record. In Integrant, anything can be dependent on anything else. The dependencies are resolved from the configuration before it's initialized into a system.

- Mount [[https://github.com/tolitius/mount][see this]]
  - Sample dev application in the repository is very useful to understand the function of mount's component runtime dependency management. You can start, stop, reset the workflow of application starting jetty web server, then connecting a database, initializing application's state, then nrepl server.
- Mount-Lite [[https://github.com/ekroon/mount-lite][see this]]
  - Not sure this is useful because this is one-man project, no new features compared with the orginal mount project.

* Data visualization Library & Tool
- plotly.js [[https://github.com/plotly/plotly.js][see this]]

* Logging in Clojure
https://spin.atomicobject.com/2015/05/11/clojure-logging/
- Use clojure.tools.logging : This library uses the following underlying java logging library in order of preference:
  - slf4j : This is not a loggin library, it's actually an API meant to wrap a variety of other logging libraries such as log4j, logback.
  - commons-logging
  - log4j : out of date, replaced by logback ...
  - java.util.logging : simple log with no complexity but weak functionity
- Use clojure.tools.logging with logback (best choice)
#+BEGIN_SRC clojure
{% highlight clojure %}
 :dependencies [...
                 [org.clojure/tools.logging "0.3.1"]
                 ; No need to specify slf4j-api, it’s required by logback
                 [ch.qos.logback/logback-classic "1.1.3"]
                 ...]
{% endhighlight %}
#+END_SRC
- Logback configuration using resources/logback.xml : An example of logback.xml you can set a log level for root or sub namespaces, and log format:

#+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    <encoder>
      <pattern>%d{ISO8601,Europe/London} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <!-- Show debug logs that originate from our namespace -->
  <property name="level" value="DEBUG"/>
  <logger name="nsp.core" level="${level}"/>
  <logger name="org.eclipse.jetty.server" level="WARN"/>
  <logger name="org.eclipse.jetty.util.log" level="WARN"/>

  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
#+END_SRC

* clojure cljfx for desktop applications
- game engine can be written by clojure [[https://defold.com/tutorials/getting-started/][see this]]
- Reveal - read eval visualization for clojure [[https://github.com/vlaaad/reveal][see this]] --> advanced visual REPLs

* E1: 데이터 기반 어플리케이션 개발에 대한 가능성 탐색
- React + Redux : React Component and Flux Architecture 이해
- Fulcro : co-located query and ident, initial-state based on application database (state), react-based stateful component
- Pathom : Parser for EQL(EDN Query Language) supporting datomic pull-like query, from Om.next concept
- Walkable : a serious way to fetch data from SQL for Clojure: Datomic pull (Graphql-ish) syntax, Clojure flavered filtering and more
- How about application potential built-on Fulcro + Pathom + Walkable?
  - All clojure(script) based - unified language across client and server
  - EQL based data communication - simple code, less code
  - Easy migration from SQL to Datomic or others - seamless, incremental migration path is possible

* E2: Migration from SQL to Datomic
- From Postgres to Datomic [[https://grishaev.me/en/pg-to-datomic/][see this]]
- Migration Common Interface for SQL [[https://github.com/weavejester/ragtime][see this]]
- HoneySQL and HoneyEQL
  - HoneySQL transforms clojure data structures into SQL format so you don't need to write SQL manually. Also using HoneySQL makes you program a complex SQL programatically.
  - HoneyEQL parses EQL and gets output from SQL DB. First sql-db-metadata (databases, schemas, tables, columns) which can be retrieved from JDBC connection is converted to honey-eql-metadata (entities, attributes, primary keys, foreign keys, one-to-one relation, etc), then an eql-node results in some relevant data in SQL DB if some attributes in honey-eql-metadata are there matched for the eql-node. As of now, PostgresSQL and MySQL only are supported. For me, Microsoft SQL Server needs to be supported so I will make it.

* Who did a great work on clojure development, specially thanks mentioned in the community:
- Rich Hickey & Cognitect team for Clojure and Datomic
- David Nolen for bringing many fresh ideas to the community including om.next
- James Reeves for Duct framework. The best development experience I've ever had
- Tony Kay for his heroic work on fulcro that showed me how great things can be done
- Wilker Lucio for pathom and being very supportive
- Sean Corfield for clojure.java.jdbc which we all use extensively
- Bozhidar Batsov and CIDER team!!!
