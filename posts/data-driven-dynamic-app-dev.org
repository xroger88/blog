#+TITLE: Idea on data-driven dynamic application development
#+tags: dev idea
#+TODO: TODO(t) | DONE(d)
#+STARTUP: logdone

applicaiton development ...

* Reference
clojure is functional and data-driven

Effective Programs - 10 Years of Clojure by Rich Hickey might be interesting as well. It gives an overview of the reasoning behind the design of Clojure and how it compares to other languages. As for convincing the other developers (and how the Clojure approach compares to other languages) the talk "Solving Problems the Clojure Way - Rafal Dittwald" is very good.

* I1: Data-driven Dynamic Application Development
(*Data-App* Design & Implementation)
** Rationale
일반적인 서버 및 클라이언트 구조에서 서버는 다수의 클라이언트와 세션을 맺고 세션 정보 및
어플리케이션 관리 정보를 바탕으로 클라이언트 요청을 처리하며, 클라이언트는
사용자 UI를 제공하여 서버에 필요한 정보를 요청하거나 업데이트하고 그 결과를
사용자에게 제공한다. 여기서 주요한 정보는 세션 및 어플리케이션 정보인데, 세션
정보는 휘발성으로 메모리에서 관리되며 어플리케이션 정보는 전체 어플리케이션에서
관리되는 엔터티의 집합으로서 영구저장이 될 수 있도록 DB에 저장 및 관리된다.

이러한 구조에서 발생되는 비효율은 다음과 같다. 첫째, 빈번한 요청/응답에 따른
통신 오버헤드 및 offline 이용이 불가함. 둘째, 어플리게이션 엔터티를 변경하기 위해서는 DB 스키마 변경 및
서버 API 변경, 클라이언트 변경에 모두 필요하기에 업데이트 및 리비젼이 쉽지 않음.

웹 어플리케이션 모델을 기준으로 위 두가지 문제점의 해결방안을 모색해 보자. 웹의
경우 브라우저 UI, 서버 API 처리, 데이터 저장/관리 등이 고려되어야 한다. 기본
브라우저 관리 UI를 통해서 동적으로 DB 스키마를 추가/변경할 수 있어야 하며,
API 라우팅 관점에서 새로운 루트가 추가/변경 될수 있어야 한다. API 루트 변경과 DB
스키마 변경이 동적으로 이루어 질 경우 이의 정합성이 보장되어야 하는데, 이를 위한
방안이 요구된다. Data-driven으로 API 루트에 대하여 저장 및 로딩이 관리되어야
하고, 스키마 또한 저장 및 로딩이 가능해야 한다. 클라이언트의 경우 싱크(초기화?) 과정을
통해서 변경된 루트 및 스키마 정보를 서버로 부터 로드하여 UI가 업데이트될 수
있어야 한다.

기본 관리 UI의 경우 하기 사항들이 가능해야 할 것으로 보인다.
- 어플리케이션 Lifecycle 관리 (어플리케이션 리스트 UI 제공)
  + 생성 (이름, 스키마, 루트, UI, 부가정보 등)
  + 시작/중지
  + 삭제
  + 배포방식(embedded, container)
  + 스키마 에디터, API 루트 에디터, UI 에디터 지원
- 어플리케이션 스키마(데이터 모델) 템플릿 관리 (스키마 리스트 UI 제공)
  + 생성 (이름, 속성, ...)
  + 변경 (히스토리 관리 필요?)
  + 삭제
  + 스키마 에디터 지원
- 어플리케이션 API (API 모델) 템플릿 관리 (API 리스트 UI 제공)
  + 생성 (이름, 속성, ...)
  + 변경 (히스토리 관리 필요?)
  + 삭제
  + API 루트 에디터 지원
- 어플리케이션 UI (UI 모델) 템플릿 관리 (UI 리스트 UI 제공)
  + 생성 (이름, 속성, ...)
  + 변경 (히스토리 관리 필요?)
  + 삭제
  + UI 에디터 지원

스키마, API, UI 모두가 data (edn format) 형태로 서버에 저장되고, 필요시 로딩되어
코드로 활성화 될 수 있어야 한다. 클로저 언어 기반으로 Datomic Schema(datalog), Reitit API
routes(http/ring), Reitit frontend (Reagent/Hiccup) 등을 활용하여 동작가능한 프로토타입을
만들어 보자.

Swagger OpenAPI 스팩을 근간으로 UI interaction, 스팩 editor, 스팩 기반 클라/서버
stub code 생성을 제공하여 API를 쉽게 개발할 수 있도록 하고 있다. 유사하게
clojure spec 을 확장하여 data-app spec을 정의하고 이를 기반으로 app-db, app-ui,
app-api 를 생성하면 어떨까? app-ui -> app-api -> app-db 데이타 흐름을 고려한
data-app system을 구성하자. 완전 clojure 전용으로 최대한 심플하게 동작하는 app을
만들어 보자.

어플리케이션 생명주기관리를 위하여 Component's system 개념을 활용하자. 초기
시스템의 경우 기본 컴포넌트를 가지고 있고, 어플리케이션 추가 및 삭제시 해당
컴포넌트가 시스템에 추가 및 삭제될 수 있도록 하자.

어플 생성시 개별 논리DB를 생성해야 할지 결정이 필요하다. 메인DB의 경우 사용자 및
권한 관리, 어플 관리, 스키마/API/UI 템플릿 관리를 위한 데이터를 다루고, 개별
어플은 별도의 논리DB에서 템플릿 확장 및 변경을 통하여 유지되는 것이 확장성 및
운영성에 적합하지 않을 까 생각한다.

배포 관점에서 서버 프로세스에 멀티 어플을 호스팅 할 경우(embedded, dev stage),
웹서버의 경우 별도 포트를 기반으로 쓰레드 인스턴스가 있어야 하지 않을까? 만약에
컨테이너로 배포(container, prod stage)가 된다면 포트 제약은 없어지고 별도의 소스
생성 및 컴파일, 컨테이너 제작 결과물이 제공되어야 한다.

** Swagger OpenAPI specification (https://swagger.io)
The OpenAPI Specification (OAS) defines a standard, language-agnostic interface
to RESTful APIs which allows both humans and computers to discover and
understand the capabilities of the service without access to source code,
documentation, or through network traffic inspection. When properly defined, a
consumer can understand and interact with the remote service with a minimal
amount of implementation logic.

An OpenAPI definition can then be used by documentation generation tools to
display the API, code generation tools to generate servers and clients in
various programming languages, testing tools, and many other use cases.

*** Swagger-core : OpenAPI spec read/write/transform
*** Swagger-ui : javascript based SPA for swagger based API interaction
*** Swagger-editor : OpenAPI spec UI editor (validation included, JSON/YAML)
*** Swagger-codegen : OpenAPI spec based client/server stub code geneartion in various lanaguages

** 애플리게이션 관점에서 공유 데이타에 대한 저장 및 처리와 개인 데이타에 대한 저장 및 처리 분리
Todo 애플리케이션을 가정할 경우 공유 데이타과 개인 데이타는 무엇인가?
Todo 애플리케이션을 datascript + rum으로 로컬에 구현하는 경우 스키마, UI
정의되고 이를 바탕으로 Todo add, delete, modify가 이루어지며 로컬 스토리지에
저장 및 로딩된다. 사용자가 Todo App을 만든다고 할때, 서버로 부터 가져와 할 것은
스키마 및 UI 데이타이고 로컬에 App 데이타가 없을 경우 서버에 있는 App 데이타를
요청하여 로딩한다. 작업 완료후 서버에 App 데이타를 전송(명시적으로 사용자
진행함?)하는 동시에 로컬에 저장한다.

서버의 datomic과 클라의 data-script간의 동기화 지원 라이브러리가 있으나, 얼마나
유용한지에 대하여 검증이 필요하다. 서버에서  tx가 일어나면 이를 전송하여
클라에서 반영하고, 클라에서 tx를 하면 서버에 전달되어 반영되는 방식이다.
https://github.com/metasoarous/datsync

** 공통 데이타 처리
응응 인스턴스간에 공유되는 데이타로서 스키마 및 UI 모델이 해당함
** 개별 데이타 처리
개별로 관리되어야 할 App 데이타. 로컬 저장은 스트링으로 변환하여 진행함. 서버의
경우 데이텀을 기준으로 저장할 것인가? 로컬 저장된 개별 데이타는 현재의 상태를
저장한 것이고, 기본적으로는 서버로 부터 현재 db를 기준으로 데이타를 가지고
오지만 사용자 요청애 따라서 과거 상태의 db로 부터 데이타를 가지고 올 수 도 있지
않나. 이 부분을 어떻케 처리할 것인지...


