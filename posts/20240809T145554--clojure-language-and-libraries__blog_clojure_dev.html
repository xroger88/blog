title: Clojure Language and Libraries
date: <2019-10-01 Tue 14:55>
tags: clojure,dev
---
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org00daae3">1. Introduction</a></li>
<li><a href="#org01224f5">2. Basic References</a></li>
<li><a href="#org81fdd25">3. Build &amp; Debugging Tools</a></li>
<li><a href="#org3b69914">4. Language Extension Libraries</a></li>
<li><a href="#org2dec268">5. Asynchronous Abstraction Libraries</a></li>
<li><a href="#orgac859df">6. Application Framework &amp; Libraries</a></li>
<li><a href="#org76c7313">7. Database as a value</a></li>
<li><a href="#orge6e61ef">8. SQL for Clojure(Script)</a></li>
<li><a href="#orgdaa941b">9. Reloaded Workflow [Application State Management]</a></li>
<li><a href="#orgec7462d">10. Data visualization Library &amp; Tool</a></li>
<li><a href="#orgabc7eec">11. Logging in Clojure</a></li>
<li><a href="#org3d10833">12. clojure cljfx for desktop applications</a></li>
<li><a href="#org53019e9">13. E1: 데이터 기반 어플리케이션 개발에 대한 가능성 탐색</a></li>
<li><a href="#orge3e3bf5">14. E2: Migration from SQL to Datomic</a></li>
<li><a href="#orge51d151">15. Who did a great work on clojure development, specially thanks mentioned in the community:</a></li>
</ul>
</div>
</div>
<p>
클로저 언어 개발 환경 구축 및 유용한 라이브러리들에 대하여 살펴본다.
</p>

<div id="outline-container-org00daae3" class="outline-2">
<h2 id="org00daae3"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>What is Clojure? Clojure is a programming language created by Rich Hickey, that was released in 2007.</li>
<li>It is: A dialect of Lisp <code>Powerful with many, many brackets Hosted on the Java Virtual Machine (JVM) Parasitises Java’s stability/performance and can use Java libraries Dynamically compiled =Faster than scripting languages. Turned into Java byte code for the JVM An impure functional programming language</code> Does not enforce the functional paradigm Aimed at Concurrency / Asynchronous Programming Currently at version 1.7, see more <a href="https://medium.com/@FunctionalWorks/from-0-to-clojure-in-540-seconds-7ce6842f57f9">article1</a> <a href="https://medium.com/@val.vvalval/what-datomic-brings-to-businesses-e2238a568e1c">article2</a></li>
</ul>
</div>
</div>
<div id="outline-container-org01224f5" class="outline-2">
<h2 id="org01224f5"><span class="section-number-2">2.</span> Basic References</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li><b>Programming Clojure</b> authored by Stuart Halloway : 기본 입문서</li>
<li><a href="https://www.braveclojure.com/introduction/">CLOJURE for the BRAVE and TRUE</a> : 클로저 개발에 필요한 것들을 쉽게 자세히 설명해 주는 책! (필독 강추)</li>
</ul>
</div>
</div>

<div id="outline-container-org81fdd25" class="outline-2">
<h2 id="org81fdd25"><span class="section-number-2">3.</span> Build &amp; Debugging Tools</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Leiningen</li>
<li>Cider in emacs</li>
<li>lein-figwheel &amp; figwheel-main for clojurescript</li>
<li>shadow-cljs for clojurescript</li>
<li>rebel-readline</li>
<li>tools.deps - deps.edn</li>
</ul>
</div>
</div>

<div id="outline-container-org3b69914" class="outline-2">
<h2 id="org3b69914"><span class="section-number-2">4.</span> Language Extension Libraries</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>Monad (algo.monad)</li>
</ul>
</div>
</div>

<div id="outline-container-org2dec268" class="outline-2">
<h2 id="org2dec268"><span class="section-number-2">5.</span> Asynchronous Abstraction Libraries</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Manifold by Zach Tellman
<ul class="org-ul">
<li>high level abstractions for asynchronous things in Clojure : <a href="https://medium.com/@functionalhuman/a-tour-of-manifold-an-easy-to-use-library-of-building-blocks-for-asynchronous-programming-f4bb5d9c6ba9">a tour of manifold an easy to use library of building blocks for asynchronous programming</a></li>
<li>Manifold.deferred - Methods for creating, transforming, and interacting with asynchronous values.</li>
<li>Manifold.streams - Manifold’s streams provide mechanisms for asynchronous puts and takes, timeouts, and backpressure. They are compatible with Java’s BlockingQueues, Clojure's lazy sequences, and core.async's channels. Methods for converting to and from each are provided.</li>
<li>Manifold.bus - Manifold also provides a simple event bus that can be used for pub/sub communication.</li>
</ul></li>
<li>Promesa</li>
<li>Porsas (metosin) - tools for precompiling the functions to convert database results into Clojure values. This enables basically Java-fast database queries using idiomatic Clojure.</li>
</ul>
</div>
</div>

<div id="outline-container-orgac859df" class="outline-2">
<h2 id="orgac859df"><span class="section-number-2">6.</span> Application Framework &amp; Libraries</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>Ring (HTTP support in clojure)
<ul class="org-ul">
<li>wrap-params (parsing params)</li>
<li>wrap-reload (for development)</li>
<li>wrap-resource and wrap-file-info (static files)</li>
</ul></li>
<li>Route match and dispatch, Restful Application Libraries
<ul class="org-ul">
<li>Compojure</li>
<li>Bidi (JUXT)</li>
<li>Compojure-api</li>
<li>Liberator - <a href="https://github.com/clojure-liberator/liberator">clojure-liberator</a></li>
<li>Reitit</li>
</ul></li>
<li>Re-frame (event/effect/subscription, application-state management)</li>
<li>Reagent (react-like component render, data -&gt; hiccup conversion)</li>
<li>Hiccup - HTML representation in clojure</li>
<li>Duck Framework for Server Application Dev - <a href="https://github.com/duct-framework/duct">github</a>
Duct is a highly modular framework for building server-side applications in Clojure using data-driven architecture. It is similar in scope to Arachne, and is based on Integrant. Duct builds applications around an immutable configuration that acts as a structural blueprint. The configuration can be manipulated and queried to produce sophisticated behavior.
<ul class="org-ul">
<li><a href="https://github.com/duct-framework/docs/blob/master/GUIDE.rst">Guide doc</a></li>
<li>see a lot of modules in <a href="https://github.com/duct-framework/duct/wiki/Modules">github</a>
Clojure/Datomic migrations library branched from rkneufeld/conformity <a href="https://github.com/magnetcoop/stork">see this</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org76c7313" class="outline-2">
<h2 id="org76c7313"><span class="section-number-2">7.</span> Database as a value</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>Datomic - immutable, single writer model (reified transaction): <a href="https://www.datomic.com">datomic home</a></li>
<li>Crux - document oriendted bitemporality (tx-time, valid-time), unbundled database : <a href="https://opencrux.com">crux home</a>
<ul class="org-ul">
<li>Crux Console Implementation - modify it as you want</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge6e61ef" class="outline-2">
<h2 id="orge6e61ef"><span class="section-number-2">8.</span> SQL for Clojure(Script)</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>clojure.java.jdbc, jdbc.next - see <a href="https://github.com/seancorfield/next-jdbc">github</a></li>
<li>how to connect mssql</li>
</ul>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #c792ea;">{</span><span style="color: #ffcb6b;">%</span> highlight clojure <span style="color: #ffcb6b;">%</span><span style="color: #c792ea;">}</span>
<span style="color: #c792ea;">(</span>require '<span style="color: #f78c6c;">[</span>next.jdbc <span style="color: #f78c6c;">:as</span> jdbc<span style="color: #f78c6c;">]</span><span style="color: #c792ea;">)</span>
<span style="color: #c792ea;">(</span><span style="color: #89DDFF;">def</span> <span style="color: #ffcb6b;">db</span> <span style="color: #f78c6c;">{</span><span style="color: #f78c6c;">:dbtype</span> <span style="color: #c3e88d;">"mssql"</span>
         <span style="color: #f78c6c;">:dbname</span> <span style="color: #c3e88d;">"database-name"</span>
         <span style="color: #f78c6c;">:host</span> <span style="color: #c3e88d;">"host"</span> <span style="color: #676E95;">;;</span><span style="color: #676E95;">optional</span>
         <span style="color: #f78c6c;">:port</span> <span style="color: #c3e88d;">"port"</span> <span style="color: #676E95;">;;</span><span style="color: #676E95;">optional</span>
         <span style="color: #f78c6c;">:user</span> <span style="color: #c3e88d;">"sql-authentication-user-name"</span>
         <span style="color: #f78c6c;">:password</span> <span style="color: #c3e88d;">"password"</span><span style="color: #f78c6c;">}</span><span style="color: #c792ea;">)</span>
<span style="color: #c792ea;">(</span><span style="color: #89DDFF;">def</span> <span style="color: #ffcb6b;">con</span> <span style="color: #f78c6c;">(</span><span style="color: #c792ea;">jdbc</span>/get-connection db<span style="color: #f78c6c;">)</span><span style="color: #c792ea;">)</span>
<span style="color: #c792ea;">(</span><span style="color: #c792ea;">jdbc</span>/execute! con <span style="color: #f78c6c;">[</span><span style="color: #c3e88d;">"select * from sys.objects  where type = 'U'"</span><span style="color: #f78c6c;">]</span><span style="color: #c792ea;">)</span>

<span style="color: #676E95;">; </span><span style="color: #676E95;">leiningen configuration</span>
<span style="color: #f78c6c;">:dependencies</span> <span style="color: #c792ea;">[</span><span style="color: #f78c6c;">[</span><span style="color: #c792ea;">seancorfield</span>/next.jdbc <span style="color: #c3e88d;">"1.0.13"</span><span style="color: #f78c6c;">]</span>
               <span style="color: #f78c6c;">[</span><span style="color: #c792ea;">com.microsoft.sqlserver</span>/mssql-jdbc <span style="color: #c3e88d;">"7.4.1.jre11"</span><span style="color: #f78c6c;">]</span><span style="color: #c792ea;">]</span>
<span style="color: #c792ea;">{</span><span style="color: #ffcb6b;">%</span> endhighlight <span style="color: #ffcb6b;">%</span><span style="color: #c792ea;">}</span>
</pre>
</div>
<ul class="org-ul">
<li>db spec -&gt; db source -&gt; db connection</li>
<li>Primitive SQL APIs: plan, execute!, execute-one!</li>
<li>Friendly SQL Functions: insert!, insert-multi!, query, update!, delete!
If you need more expressiveness, consider one of the following libraries to build SQL/parameter vectors, or run queries:</li>

<li>HoneySQL &#x2013; a composable DSL for creating SQL/parameter vectors from Clojure data structures</li>
<li>seql &#x2013; a simplified EQL-inspired query language, built on next.jdbc (as of release 0.1.6)</li>
<li>SQLingvo &#x2013; a composable DSL for creating SQL/parameter vectors</li>
<li>Walkable &#x2013; full EQL query language support for creating SQL/parameter vectors</li>
<li>HugSQL &#x2013; If you prefer to write your SQL separately from your code, take a look at HugSQL</li>

<li>RagTime - <a href="https://github.com/weavejester/ragtime">see this</a>
<ul class="org-ul">
<li>Ragtime is a Clojure library for migrating structured data in a way that's database independent. It defines a common interface for expressing migrations, much like Ring defines a common interface for expressing web applications. Ragtime needs three pieces of data to work: migratable data store, an ordered sequence of migrations,strategy on how to deal with conflicts</li>
</ul></li>
<li>HugSQL</li>
<li>HoneySQL</li>
<li>Walkable</li>
</ul>
</div>
</div>

<div id="outline-container-orgdaa941b" class="outline-2">
<h2 id="orgdaa941b"><span class="section-number-2">9.</span> Reloaded Workflow [Application State Management]</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>Introduction
<ul class="org-ul">
<li>The reloaded workflow uses components that can be started or stopped, arranged together into a system. During development, the system is started in a running REPL. After source files are changed, the system is stopped, the source files reloaded, and the system started once more. This can be put into a single command or even attached to a shortcut. A component could include stuff like reading configuration database connection running a Jetty server A short list of libraries offering support for this approach: Component <a href="https://github.com/stuartsierra/component">see this</a> [Excerpted from Stuartssierra's component github site]</li>
</ul></li>
</ul>
<blockquote>
<p>
A component is a collection of functions or procedures which share some runtime
state. Some examples of components:
</p>
<ul class="org-ul">
<li>Database access: query and insert fucntions sharing a database connection</li>
<li>External API service: functions to send receive data sharing an HTTP
connection pool</li>
<li>Web server: functions to handle different routes sharing all the runtime state
of the web application, such as a session store</li>
<li>In-memory cache: functions to get and set data in a shared mutable reference
such as a Clojure Atom or Ref</li>
</ul>
<p>
Commponents are intended to help manage stateful resources within a function paradigm.
</p>
</blockquote>
<ul class="org-ul">
<li>Integrant <a href="https://github.com/weavejester/integrant">see this</a>
<ul class="org-ul">
<li>Integrant is a Clojure (and ClojureScript) micro-framework for building applications with data-driven architecture. It can be thought of as an alternative to Component or Mount, and was inspired by Arachne and through work on Duct. Rationale: Integrant was built as a reaction to fix some perceived weaknesses with Component. In Component, systems are created programmatically. Constructor functions are used to build records, which are then assembled into systems. In Integrant, systems are created from a configuration data structure, typically loaded from an edn resource. The architecture of the application is defined through data, rather than code. In Component, only records or maps may have dependencies. Anything else you might want to have dependencies, like a function, needs to be wrapped in a record. In Integrant, anything can be dependent on anything else. The dependencies are resolved from the configuration before it's initialized into a system.</li>
</ul></li>

<li>Mount <a href="https://github.com/tolitius/mount">see this</a>
<ul class="org-ul">
<li>Sample dev application in the repository is very useful to understand the function of mount's component runtime dependency management. You can start, stop, reset the workflow of application starting jetty web server, then connecting a database, initializing application's state, then nrepl server.</li>
</ul></li>
<li>Mount-Lite <a href="https://github.com/ekroon/mount-lite">see this</a>
<ul class="org-ul">
<li>Not sure this is useful because this is one-man project, no new features compared with the orginal mount project.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgec7462d" class="outline-2">
<h2 id="orgec7462d"><span class="section-number-2">10.</span> Data visualization Library &amp; Tool</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>plotly.js <a href="https://github.com/plotly/plotly.js">see this</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgabc7eec" class="outline-2">
<h2 id="orgabc7eec"><span class="section-number-2">11.</span> Logging in Clojure</h2>
<div class="outline-text-2" id="text-11">
<p>
<a href="https://spin.atomicobject.com/2015/05/11/clojure-logging/">https://spin.atomicobject.com/2015/05/11/clojure-logging/</a>
</p>
<ul class="org-ul">
<li>Use clojure.tools.logging : This library uses the following underlying java logging library in order of preference:
<ul class="org-ul">
<li>slf4j : This is not a loggin library, it's actually an API meant to wrap a variety of other logging libraries such as log4j, logback.</li>
<li>commons-logging</li>
<li>log4j : out of date, replaced by logback &#x2026;</li>
<li>java.util.logging : simple log with no complexity but weak functionity</li>
</ul></li>
<li>Use clojure.tools.logging with logback (best choice)</li>
</ul>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #c792ea;">{</span><span style="color: #ffcb6b;">%</span> highlight clojure <span style="color: #ffcb6b;">%</span><span style="color: #c792ea;">}</span>
 <span style="color: #f78c6c;">:dependencies</span> <span style="color: #c792ea;">[</span>...
                 <span style="color: #f78c6c;">[</span><span style="color: #c792ea;">org.clojure</span>/tools.logging <span style="color: #c3e88d;">"0.3.1"</span><span style="color: #f78c6c;">]</span>
                 <span style="color: #676E95;">; No need to specify slf4j-api, it&#8217;s required by logback</span>
                 <span style="color: #f78c6c;">[</span><span style="color: #c792ea;">ch.qos.logback</span>/logback-classic <span style="color: #c3e88d;">"1.1.3"</span><span style="color: #f78c6c;">]</span>
                 ...<span style="color: #c792ea;">]</span>
<span style="color: #c792ea;">{</span><span style="color: #ffcb6b;">%</span> endhighlight <span style="color: #ffcb6b;">%</span><span style="color: #c792ea;">}</span>
</pre>
</div>
<ul class="org-ul">
<li>Logback configuration using resources/logback.xml : An example of logback.xml you can set a log level for root or sub namespaces, and log format:</li>
</ul>

<div class="org-src-container">
<pre class="src src-xml">&lt;?<span style="color: #89DDFF;">xml</span> <span style="color: #8d92af;">version="1.0" encoding="UTF-8"</span>?&gt;
&lt;<span style="color: #82aaff;">configuration</span>&gt;
  &lt;<span style="color: #82aaff;">appender</span> <span style="color: #ffcb6b;">name</span>=<span style="color: #c3e88d;">"STDOUT"</span> <span style="color: #ffcb6b;">class</span>=<span style="color: #c3e88d;">"ch.qos.logback.core.ConsoleAppender"</span>&gt;
    <span style="color: #676E95;">&lt;!-- </span><span style="color: #676E95;">encoders are assigned the type</span>
<span style="color: #676E95;">         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default</span><span style="color: #676E95;"> --&gt;</span>
    &lt;<span style="color: #82aaff;">encoder</span>&gt;
      &lt;<span style="color: #82aaff;">pattern</span>&gt;%d{ISO8601,Europe/London} [%thread] %-5level %logger{36} - %msg%n&lt;/<span style="color: #82aaff;">pattern</span>&gt;
    &lt;/<span style="color: #82aaff;">encoder</span>&gt;
  &lt;/<span style="color: #82aaff;">appender</span>&gt;

  <span style="color: #676E95;">&lt;!-- </span><span style="color: #676E95;">Show debug logs that originate from our namespace</span><span style="color: #676E95;"> --&gt;</span>
  &lt;<span style="color: #82aaff;">property</span> <span style="color: #ffcb6b;">name</span>=<span style="color: #c3e88d;">"level"</span> <span style="color: #ffcb6b;">value</span>=<span style="color: #c3e88d;">"DEBUG"</span>/&gt;
  &lt;<span style="color: #82aaff;">logger</span> <span style="color: #ffcb6b;">name</span>=<span style="color: #c3e88d;">"nsp.core"</span> <span style="color: #ffcb6b;">level</span>=<span style="color: #c3e88d;">"${level}"</span>/&gt;
  &lt;<span style="color: #82aaff;">logger</span> <span style="color: #ffcb6b;">name</span>=<span style="color: #c3e88d;">"org.eclipse.jetty.server"</span> <span style="color: #ffcb6b;">level</span>=<span style="color: #c3e88d;">"WARN"</span>/&gt;
  &lt;<span style="color: #82aaff;">logger</span> <span style="color: #ffcb6b;">name</span>=<span style="color: #c3e88d;">"org.eclipse.jetty.util.log"</span> <span style="color: #ffcb6b;">level</span>=<span style="color: #c3e88d;">"WARN"</span>/&gt;

  &lt;<span style="color: #82aaff;">root</span> <span style="color: #ffcb6b;">level</span>=<span style="color: #c3e88d;">"INFO"</span>&gt;
    &lt;<span style="color: #82aaff;">appender-ref</span> <span style="color: #ffcb6b;">ref</span>=<span style="color: #c3e88d;">"STDOUT"</span>/&gt;
  &lt;/<span style="color: #82aaff;">root</span>&gt;
&lt;/<span style="color: #82aaff;">configuration</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d10833" class="outline-2">
<h2 id="org3d10833"><span class="section-number-2">12.</span> clojure cljfx for desktop applications</h2>
<div class="outline-text-2" id="text-12">
<ul class="org-ul">
<li>game engine can be written by clojure <a href="https://defold.com/tutorials/getting-started/">see this</a></li>
<li>Reveal - read eval visualization for clojure <a href="https://github.com/vlaaad/reveal">see this</a> &#x2013;&gt; advanced visual REPLs</li>
</ul>
</div>
</div>

<div id="outline-container-org53019e9" class="outline-2">
<h2 id="org53019e9"><span class="section-number-2">13.</span> E1: 데이터 기반 어플리케이션 개발에 대한 가능성 탐색</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>React + Redux : React Component and Flux Architecture 이해</li>
<li>Fulcro : co-located query and ident, initial-state based on application database (state), react-based stateful component</li>
<li>Pathom : Parser for EQL(EDN Query Language) supporting datomic pull-like query, from Om.next concept</li>
<li>Walkable : a serious way to fetch data from SQL for Clojure: Datomic pull (Graphql-ish) syntax, Clojure flavered filtering and more</li>
<li>How about application potential built-on Fulcro + Pathom + Walkable?
<ul class="org-ul">
<li>All clojure(script) based - unified language across client and server</li>
<li>EQL based data communication - simple code, less code</li>
<li>Easy migration from SQL to Datomic or others - seamless, incremental migration path is possible</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge3e3bf5" class="outline-2">
<h2 id="orge3e3bf5"><span class="section-number-2">14.</span> E2: Migration from SQL to Datomic</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>From Postgres to Datomic <a href="https://grishaev.me/en/pg-to-datomic/">see this</a></li>
<li>Migration Common Interface for SQL <a href="https://github.com/weavejester/ragtime">see this</a></li>
<li>HoneySQL and HoneyEQL
<ul class="org-ul">
<li>HoneySQL transforms clojure data structures into SQL format so you don't need to write SQL manually. Also using HoneySQL makes you program a complex SQL programatically.</li>
<li>HoneyEQL parses EQL and gets output from SQL DB. First sql-db-metadata (databases, schemas, tables, columns) which can be retrieved from JDBC connection is converted to honey-eql-metadata (entities, attributes, primary keys, foreign keys, one-to-one relation, etc), then an eql-node results in some relevant data in SQL DB if some attributes in honey-eql-metadata are there matched for the eql-node. As of now, PostgresSQL and MySQL only are supported. For me, Microsoft SQL Server needs to be supported so I will make it.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge51d151" class="outline-2">
<h2 id="orge51d151"><span class="section-number-2">15.</span> Who did a great work on clojure development, specially thanks mentioned in the community:</h2>
<div class="outline-text-2" id="text-15">
<ul class="org-ul">
<li>Rich Hickey &amp; Cognitect team for Clojure and Datomic</li>
<li>David Nolen for bringing many fresh ideas to the community including om.next</li>
<li>James Reeves for Duct framework. The best development experience I've ever had</li>
<li>Tony Kay for his heroic work on fulcro that showed me how great things can be done</li>
<li>Wilker Lucio for pathom and being very supportive</li>
<li>Sean Corfield for clojure.java.jdbc which we all use extensively</li>
<li>Bozhidar Batsov and CIDER team!!!</li>
</ul>
</div>
</div>
